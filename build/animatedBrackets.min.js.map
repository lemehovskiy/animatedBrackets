{"version":3,"sources":["animatedBrackets.es6"],"names":["factory","define","amd","exports","module","require","jQuery","$","fn","animatedBrackets","options","set_dash","settings","element","length","get_path_length","get","attr","path","totalLength","prevPos","polyline","i","points","numberOfItems","pos","getItem","Math","sqrt","pow","x","y","animate_brackets","TimelineLite","staggerTo","duration","stroke-dashoffset","delay","draw_polyline","points_str","forEach","item","element_width","element_height","color","stroke_width","extend","this","each","draw_brackets","brackets_config","bracket","$this_width","$this_height","is_animated","is_inited","$this","svgElement","document","createElementNS","brackets_points","split","bracket_points_arr","push","append","css","position","width","height","left","top","overflow","window","on","outerWidth","outerHeight","isOnScreen","find","win","viewport","scrollTop","scrollLeft","right","bottom","bounds","offset","deltas","min"],"mappings":"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","file":"animatedBrackets.min.js","sourcesContent":["/*\n\n animatedBrackets\n\n Author: lemehovskiy\n\n */\n\n;(function (factory) {\n    'use strict';\n\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (typeof exports !== 'undefined') {\n        module.exports = factory(require('jquery'));\n    } else {\n        factory(jQuery);\n    }\n})\n(function ($) {\n\n    $.fn.animatedBrackets = function (options) {\n\n        let settings = $.extend({\n            points: [\n                '0 20, 0 0, 100 0, 100 20',\n                '100 80, 100 100, 0 100, 0 80'\n            ],\n            color: '#ffffff',\n            stroke_width: 10,\n            duration: 1,\n            delay: 1\n        }, options);\n\n\n        $(this).each(function () {\n\n            let $this = $(this),\n                $this_width = 0,\n                $this_height = 0,\n\n                brackets_config = [],\n\n                is_inited = false,\n                is_animated = false,\n\n                svgElement = $(document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"));\n\n            //generate brackets config\n            settings.points.forEach(function (points_str) {\n\n                let brackets_points = points_str.split(', ');\n\n                let bracket_points_arr = [];\n\n                brackets_points.forEach(function (item) {\n\n                    bracket_points_arr.push(item.split(' '));\n\n                });\n\n                brackets_config.push({points: bracket_points_arr});\n            });\n\n            $this.append(svgElement);\n\n            $this.css({\n                position: 'relative'\n            });\n\n            svgElement.css({\n                width: '100%',\n                height: '100%',\n                position: 'absolute',\n                left: 0,\n                top: 0,\n                overflow: 'visible'\n            });\n\n\n            brackets_config.forEach(function (bracket) {\n\n                bracket.element = $(document.createElementNS(\"http://www.w3.org/2000/svg\", 'polyline'));\n\n                svgElement.append(bracket.element);\n\n            });\n\n            $(window).on('load resize', function () {\n                $this_width = $this.outerWidth();\n                $this_height = $this.outerHeight();\n\n                draw_brackets();\n            });\n\n            $(window).on('load scroll resize', function () {\n\n                if (is_inited && $this.isOnScreen(.5, .5) && !is_animated) {\n                    animate_brackets({\n                        path: $this.find('polyline'),\n                        duration: settings.duration,\n                        delay: settings.delay\n                    });\n                    is_animated = true;\n                }\n\n            });\n\n\n            function draw_brackets() {\n\n                brackets_config.forEach(function (bracket) {\n\n                    draw_polyline({\n                        element: bracket.element,\n                        points: bracket.points,\n                        element_width: $this_width,\n                        element_height: $this_height,\n                        color: settings.color,\n                        stroke_width: settings.stroke_width\n                    });\n\n                    if (!is_animated) {\n                        set_dash({\n                            element: bracket.element,\n                        });\n                    }\n\n                });\n\n                is_inited = true;\n\n            }\n\n        });\n\n        function set_dash(settings) {\n\n            let element = settings.element;\n\n            let length = get_path_length(element.get(0));\n\n            element.attr(\"stroke-dasharray\", length);\n            element.attr(\"stroke-dashoffset\", length);\n        }\n\n\n        function get_path_length(path) {\n\n            let totalLength = 0;\n            let prevPos;\n            let polyline = path;\n            for (let i = 0; i < polyline.points.numberOfItems; i++) {\n                let pos = polyline.points.getItem(i);\n                if (i > 0) {\n                    totalLength += Math.sqrt(Math.pow((pos.x - prevPos.x), 2) + Math.pow((pos.y - prevPos.y), 2));\n                }\n                prevPos = pos;\n            }\n\n            return totalLength;\n        }\n\n        function animate_brackets(settings) {\n\n            let timeline = new TimelineLite();\n\n            timeline.staggerTo(settings.path, settings.duration, {attr: {'stroke-dashoffset': 0}}, settings.delay);\n        }\n\n\n\n        function draw_polyline(settings) {\n\n            let element = settings.element;\n\n            let points = settings.points;\n\n            let points_str = '';\n\n            points.forEach(function (item) {\n                points_str += settings.element_width / 100 * item[0] + \", \" + settings.element_height / 100 * item[1] + \" \"\n            });\n\n            element.attr(\"points\", points_str);\n\n            element.attr(\"style\", \"stroke:\" + settings.color + \"; stroke-width:\" + settings.stroke_width + \"; fill:none\"); //Set path's data\n\n\n        }\n\n    };\n\n    $.fn.isOnScreen = function (x, y) {\n\n        if (x == null || typeof x == 'undefined') x = 1;\n        if (y == null || typeof y == 'undefined') y = 1;\n\n        var win = $(window);\n\n        var viewport = {\n            top: win.scrollTop(),\n            left: win.scrollLeft()\n        };\n        viewport.right = viewport.left + win.width();\n        viewport.bottom = viewport.top + win.height();\n\n        var height = this.outerHeight();\n        var width = this.outerWidth();\n\n        if (!width || !height) {\n            return false;\n        }\n\n        var bounds = this.offset();\n        bounds.right = bounds.left + width;\n        bounds.bottom = bounds.top + height;\n\n        var visible = (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));\n\n        if (!visible) {\n            return false;\n        }\n\n        var deltas = {\n            top: Math.min(1, ( bounds.bottom - viewport.top ) / height),\n            bottom: Math.min(1, ( viewport.bottom - bounds.top ) / height),\n            left: Math.min(1, ( bounds.right - viewport.left ) / width),\n            right: Math.min(1, ( viewport.right - bounds.left ) / width)\n        };\n\n        return (deltas.left * deltas.right) >= x && (deltas.top * deltas.bottom) >= y;\n\n    };\n\n});"]}